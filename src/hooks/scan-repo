#!/bin/bash

set -e  # Exit on error

# Get the directory where this script is located and the current directory
SCRIPT_DIR="$(git config --global --get core.hookspath)"
CURRENT_DIR="$(pwd)"

# Parse command line arguments
NO_BROWSER=false
for arg in "$@"; do
    if [ "$arg" = "--no-browser" ]; then
        NO_BROWSER=true
        break
    fi
done

# Configuration
DISALLOWED_EXTENSIONS=".crt,.cer,.ca-bundle,.p7b,.p7c,.p7s,.pem,.jceks,.key,.keystore,.jks,.p12,.pfx"

# Set up paths relative to the script location
COMMIT_SCRIPTS_DIR="$SCRIPT_DIR/commit-scripts"
SECRETSCAN_PY="$COMMIT_SCRIPTS_DIR/secretscan.py"
SCAN_RESULTS_DIR="$SCRIPT_DIR/.scan_results"
REPORTS_DIR="$SCRIPT_DIR/.reports"
RESULTS_DIR="$SCRIPT_DIR/scan_results"
RESULTS_FILE="$RESULTS_DIR/scan_results.json"
DISALLOWED_FILES_LIST="$RESULTS_DIR/disallowed_files.txt"

# Function to clean up temporary files
cleanup() {
    rm -f "$SCAN_RESULTS_DIR/files_to_scan.txt"
}

# Set up cleanup on script exit
trap cleanup EXIT

# Create necessary directories if they don't exist
for dir in "$SCAN_RESULTS_DIR" "$REPORTS_DIR" "$RESULTS_DIR"; do
    if ! mkdir -p "$dir"; then
        echo "‚ùå Error: Failed to create directory: $dir"
        exit 1
    fi
done

# Check Python availability and version
if command -v python3 > /dev/null 2>&1; then
    python_cmd="python3"
    python_version=$($python_cmd --version 2>&1)
    echo "‚úì Using $python_version"
elif command -v python > /dev/null 2>&1; then
    python_cmd="python"
    python_version=$($python_cmd --version 2>&1)
    echo "‚úì Using $python_version"
else
    echo "‚ùå Error: Python3 is not installed. Secret scanning functionality will not work."
    exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "‚ùå Error: Not a git repository"
    exit 1
fi

# Check for disallowed file extensions
echo "üîç Checking for disallowed file extensions..."
IFS=',' read -ra EXTENSIONS <<< "$DISALLOWED_EXTENSIONS"
for ext in "${EXTENSIONS[@]}"; do
    (
        # Check tracked files
        git ls-files
        # Check untracked files (excluding ignored ones)
        git ls-files --others --exclude-standard
    ) | grep -i "\\${ext}$" >> "$DISALLOWED_FILES_LIST" 2>/dev/null || true
done

# Function to display HTML results
display_html_results() {
    local results_file="$1"
    if [ ! -f "$results_file" ]; then
        echo "‚ùå Error: Results file not found: $results_file"
        return 1
    fi
    
    # Get Git information
    GIT_AUTHOR=$(git config user.name)
    TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
    
    $python_cmd - <<EOF
import sys
import os
import json
sys.path.append('$COMMIT_SCRIPTS_DIR')
from secretscan import generate_html_report

# Read results file
try:
    with open('$results_file', 'r') as f:
        results_data = json.load(f)
except Exception as e:
    print(f"Error reading results file: {e}")
    sys.exit(1)

# Read disallowed files if they exist
disallowed_files = []
if os.path.exists('$DISALLOWED_FILES_LIST') and os.path.getsize('$DISALLOWED_FILES_LIST') > 0:
    with open('$DISALLOWED_FILES_LIST', 'r') as f:
        disallowed_files = [line.strip() for line in f.readlines()]

# Generate timestamp for report filename
from datetime import datetime
timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
html_report = os.path.join('$REPORTS_DIR', f'scan_report_{timestamp}.html')

# Generate the HTML report
generate_html_report(
    html_report,
    results_data=results_data,
    disallowed_files=disallowed_files
)

print(f"\nReport saved to: {html_report}")
EOF
}

echo "üîç Starting repository-wide secret scan..."

# Get all files in the repository, excluding unwanted files
echo "üìÇ Getting list of files to scan..."
$python_cmd - <<EOF
import sys
import os
sys.path.append('$COMMIT_SCRIPTS_DIR')
from config import EXCLUDED_EXTENSIONS, EXCLUDED_DIRECTORIES, DISALLOWED_EXTENSIONS
import subprocess

def get_all_files():
    # Get tracked files
    tracked = subprocess.check_output(['git', 'ls-files', '-z']).decode('utf-8').split('\0')
    # Get untracked files
    untracked = subprocess.check_output(['git', 'ls-files', '--others', '--exclude-standard', '-z']).decode('utf-8').split('\0')
    return [f for f in tracked + untracked if f]

def should_scan_file(file_path):
    # Check file extension
    ext = os.path.splitext(file_path)[1].lower().lstrip('.')
    if ext in EXCLUDED_EXTENSIONS:
        return False
        
    # Check directory
    parts = file_path.split(os.sep)
    if any(part in EXCLUDED_DIRECTORIES for part in parts):
        return False
        
    return True

def is_disallowed_file(file_path):
    ext = os.path.splitext(file_path)[1].lower()
    return ext in DISALLOWED_EXTENSIONS

# Get all files and filter them
all_files = get_all_files()
files_to_scan = [f for f in all_files if should_scan_file(f)]
disallowed = [f for f in all_files if is_disallowed_file(f)]

# Write files to scan
with open('$SCAN_RESULTS_DIR/files_to_scan.txt', 'w') as f:
    f.write('\n'.join(files_to_scan))

# Write disallowed files
with open('$DISALLOWED_FILES_LIST', 'w') as f:
    f.write('\n'.join(disallowed))

print(f"Found {len(files_to_scan)} files to scan")
print(f"Found {len(disallowed)} disallowed files")
EOF

# Count files and show progress
total_files=$(wc -l < "$SCAN_RESULTS_DIR/files_to_scan.txt")
if [ "$total_files" -eq 0 ]; then
    echo "‚ùå No files found to scan"
    exit 1
fi

echo "üìÑ Scanning $total_files files..."

# Check if secretscan.py exists and is executable
if [ ! -f "$SECRETSCAN_PY" ]; then
    echo "‚ùå Error: secretscan.py not found at $SECRETSCAN_PY"
    exit 1
fi

if [ ! -r "$SECRETSCAN_PY" ]; then
    echo "‚ùå Error: secretscan.py is not readable"
    exit 1
fi

# Run the secret scan script
cd "$CURRENT_DIR"  # Change to repository directory for scanning
echo "‚ö° Running secret scan..."

# Initialize results file
echo "[]" > "$RESULTS_FILE"

# Process each file
current_file=0
TEMP_RESULT="$SCAN_RESULTS_DIR/temp_result.json"
MAX_CONCURRENT_SCANS=5  # Set the maximum number of concurrent scans
jobs=()  # Array to hold job PIDs

while IFS= read -r file; do
    ((current_file++))
    echo -ne "\rProcessing file $current_file of $total_files"
    
    if [ -f "$file" ]; then
        # Run scan in the background
        {
            # Run scan and capture output to temporary file
            if $python_cmd "$SECRETSCAN_PY" "$file" > "$TEMP_RESULT" 2>/dev/null; then
                # If we got output and it's valid JSON, merge it with existing results
                if [ -s "$TEMP_RESULT" ] && $python_cmd -c "import json; json.load(open('$TEMP_RESULT'))" >/dev/null 2>&1; then
                    $python_cmd - <<EOF
import json
import sys

def merge_results(results_file, new_results_file):
    # Read existing results
    with open(results_file, 'r') as f:
        try:
            existing = json.load(f)
        except json.JSONDecodeError:
            existing = []
    
    # Read new results
    with open(new_results_file, 'r') as f:
        try:
            new = json.load(f)
        except json.JSONDecodeError:
            new = []
    
    # Merge and write back
    if isinstance(new, list):
        with open(results_file, 'w') as f:
            json.dump(existing + new, f, indent=2)

merge_results('$RESULTS_FILE', '$TEMP_RESULT')
EOF
                fi
            fi
        } &  # Run the scan in the background

        # Store the PID of the background job
        jobs+=($!)  # Add the PID to the jobs array

        # Limit the number of concurrent scans
        if [ ${#jobs[@]} -ge $MAX_CONCURRENT_SCANS ]; then
            # Wait for all background jobs to finish before starting new ones
            wait "${jobs[@]}"  # Wait for all jobs in the array
            jobs=()  # Clear the jobs array
        fi
    fi
done < "$SCAN_RESULTS_DIR/files_to_scan.txt"

# Wait for any remaining background jobs to finish
wait
echo  # New line after progress

# Clean up temporary files
rm -f "$TEMP_RESULT"

# Return to original directory
cd "$CURRENT_DIR"

# Check if results file exists and display results
if [ -f "$RESULTS_FILE" ] || [ -f "$DISALLOWED_FILES_LIST" ]; then
    has_content=false
    
    if [ -f "$RESULTS_FILE" ] && [ -s "$RESULTS_FILE" ]; then
        has_content=true
        echo "‚ö†Ô∏è Potential secrets found!"
    fi
    
    if [ -f "$DISALLOWED_FILES_LIST" ] && [ -s "$DISALLOWED_FILES_LIST" ]; then
        has_content=true
        echo "‚ö†Ô∏è Disallowed files found!"
    fi
    
    if [ "$has_content" = true ]; then
        echo "Generating HTML report..."
        if ! display_html_results "$RESULTS_FILE"; then
            echo "‚ùå Error: Failed to generate HTML report"
            rm -f "$DISALLOWED_FILES_LIST"  # Clean up disallowed files list after report generation
            exit 1
        fi
        
        # Clean up old reports (keep last 5) - macOS compatible version
        (cd "$REPORTS_DIR" && ls -t scan_report_*.html 2>/dev/null || true) | \
            awk 'NR>5' | \
            while read -r file; do rm -f "$REPORTS_DIR/$file"; done
            
        (cd "$SCAN_RESULTS_DIR" && ls -t scan_results_*.json 2>/dev/null || true) | \
            awk 'NR>5' | \
            while read -r file; do rm -f "$SCAN_RESULTS_DIR/$file"; done
        
        rm -f "$DISALLOWED_FILES_LIST"  # Clean up disallowed files list after report generation
    else
        echo "‚úÖ No potential secrets or disallowed files found in the repository."
        rm -f "$DISALLOWED_FILES_LIST"  # Clean up disallowed files list if no content
    fi
else
    echo "‚úÖ No potential secrets or disallowed files found in the repository."
    rm -f "$DISALLOWED_FILES_LIST"  # Clean up disallowed files list if no files exist
fi 